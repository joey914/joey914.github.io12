---
layout: post
title:  "[Java] JVM과 메모리 관리"
date:   2017-03-21 15:05:27 -0800
tags: [Sunrin, JAVA]
author: Jooholee
description: "선린인터넷고 JAVA 시간에 학습했던 내용을 바탕으로 작성한 보고서 입니다."
---

자바 가상 머신, JVM 이란?

자바 가상 머신 (Java Virtual Machine, JVM) 은 자바 바이트코드를 실행할 수 있는 주체 입니다.
보통은 인터프리터, JIT컴파일 등의 방식으로 어디서든 바이트코드를 실행할 수 있지만, 자바 프로세서 같은 경우처럼 하드웨어와 소프트웨어를 혼합해 구현할 수 있습니다.
물론, 혼합 없이 100% 하드웨어 구성으로의 구현도 가능하지만 굉장히 비효율적이라고 합니다.
따라서 자바의 바이트코드는 플랫폼에 독립적이고, 모든 자바 가상 머신은 일정 규격에 정의된 대로만 바이트코드를 실행하게 됩니다. 그래서 동일한 동작을 하도록 구현된 서로의 자바 API 들은 이론적으로 항상 CPU와 OS에 종류에 관계 없이 항상 동일하게 동작할 것을 보장합니다.

이 JVM의 특징으로는

⦁	1. 보통의 하드웨어 (Intel x86 아키텍쳐, ARM 아키텍쳐 등)들은 레지스터 기반으로 동작하는 데에 반해 JVM은 스택 기반으로 동작합니다.

⦁	2. C언어의 malloc()이나 free()같은 메모리 관리 함수를 가비지 콜렉터로 구현합니다.

⦁	3. 자바의 프로그램들은 가상머신인 JVM 위에서 실행되므로 OS나 하드웨어의 제약 없이 같은 API의 JVM만 구성되어 있다면 실행이 가능합니다.

JVM의 구조는
⦁	Class loader
⦁	Execution Engine
⦁	Garbage Collector
⦁	Runtime Data Areas

와 같은 구조로 되어있고,
Class loader란, 자바 가상머신 내부에 클래스들을 로드하고 연결 통해 적당히 배치하는 일련의 작업을 수행하는 모듈. 동적으로 클래스들을 불러옵니다.

Execution Engine이란,  Class loader를 통해 가상 머신 내부의 런타임 데이터 영역에 배치된 바이트 코드를 실행 엔진으로 실행하고, 그 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행합니다.

Garbage Collector란, 자바 가상 머신의 자동화된 메모리의 관리 기능입니다.
Garbage Collector는 Garbage Collection을 수행하는 모듈 쓰레드를 뜻합니다. 프로세스가 생성한 객체의 생존 여부를 판단하고, 더 이상 사용되지 않는 객체는 소거함으로써 메모리 관리가 자동화 되도록 합니다. 자바 가상 머신을 줄여서 JVM이라고 하듯 Garbage Collector 역시 줄여서 GC라고 부릅니다.

Runtime Data Areas란, 자바 가상 머신이 운영체제 위에서 실행되면서 할당받게 되는 메모리 영역 입니다.
런타임 데이터 영역은 6개의 영역으로 나뉩니다.
일반적인 native 프로그램과 JVM의 수행 과정의 비교

JVM :

Java에서 프로그램을 실행한다는 것은 Class파일을 자바 가상머신으로 로딩하고 바이트코드를 해석(Interpret) 하는 작업과, 메모리등의 리소스를 할당하고 관리하며 정보를 관리하는 일련의 작업들을 포괄합니다. 이때 JVM은 쓰레드 관리 및 Garbage Collection과 같은 메모리 재생 작업도 동시에 수행해줍니다.

Native :

1. 로딩
윈도우 시스템에서 실행파일은 PE(Portable Excutable)라는 파일 형식을 가지고 있습니다.
예를 들면 Visual studio로 컴파일하면 나오는 exe확장자를 가진 파일도 PE파일 형식을 가지고 있습니다.
프로그램 실행 명령이 내려지면 OS는 PE파일의 header부분을 분석해, 프로그램의 진입지점을 적절하게 메인 메모리에 로딩하게 됩니다.
그 후 프로그램의 명령에 따라서 필요한 순차적으로 명령어들을 로딩하게 됩니다.

2. 패치 (Instruction Fetch)
메모리에 로딩된 프로그램은 CPU를 동작시키기 위한 명령어인 인스트럭션(Instruction)의 집합이라고 할 수 있습니다. 컴파일이라는 것은 결과적으로 우리의 소스코드를 CPU가 이해할 수 있는 인스트럭션으로 변화시켜 주는 것입니다.
프로그램이 실행되기 위해서는 메모리에 로딩된 인스트럭션들을 순차적으로 CPU로 읽어들여야 합니다.
이러한 총 과정을 인스트럭션 패치라고 합니다.

3. 디코딩 (Instruction Decoding)
실행을 위해서는 0,1로 구성된 이진 코드를 각 필드별로 잘게 분해하여 어떤 종류의 연산을 수행 할 것인지를 결정해야 하고 연산에 필요한 연산자를 레지스터에 인가시키는 작업이 필요하다.
이러한 작업을 디코딩이라고 합니다.

4. 실행 (Execution)
디코딩 과정에서 수행 될 연산의 종류는 연산코드의 형식으로 CPU에서 실질적인 연산을 수행하는 산술논리 연산장치(arithmetic-logic unit): 줄여서 ALU에 입력됩니다.
ALU는 연산코드에 맞춰서 레지스터에 저장된 연산자들을 이요하여 연산을 수행하게 됩니다,
하나의 인스트럭션이 실행을 마치면 다히 새로운 인스트럭션을 패치해 오게 되는 과정을 반복하게 됩니다.

이와 같이 JVM프로그램과 Native프로그램의 실행 과정은 많은 차이가 있으며, 실행 속도는 가상 머신을 활용한 JVM이 떨어지나 최근에는 이전처럼 바이트코드를 순수히 인터프리트 하는 것이 아닌 JUST-IN-TIME (JIT)라는 기능을 구현하여 Native 프로그램의 속도를 따라잡고 있는 추세입니다.

Just-in-time (JIT) 컴파일

C나 C++의 컴파일러가 하는 것처럼, 첫 프로그램 실행 전 한번 컴파일 하는 대신에 프로그램을 실행하는 시점에서 필요한 부분만을 즉석으로 컴파일 하는 것을 말합니다.
JVM에서는 이를 성능 향상의 목적으로 도입하게 되었고, 매번 실행시마다 컴파일 하지 않고 이미 컴파일 된 코드를 활용하므로 상향된 성능을 기대할 수 있다.
하지만 초기 구동 시 바이트 코드를 컴파일 하는 데에 많은 시간과 메모리를 소모하므로, 정적 컴파일 된 Native 프로그램에 비해 초기 프로그램 실행 속도와 메모리 사용량에서 손해를 봅니다.
따라서 프로그램의 실행 시간이 매우 짧은 경우에는 애써 컴파일된 코드를 제대로 사용하기도 전에 프로그램이 끝나게 되어 꽤나 비효율적인 모습도 보여주고 있습니다.

JVM의 메모리 구조

![](http://www.javachobo.com/images/p6_23.jpg)

JVM은 다음과 같은 구조를 가지고 있습니다.

1. 메소드영역(Method Area)
⦁	프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 메소드 영역에 저장합니다.

⦁	이 때, 그 클래스의 클래스변수(class variable)도 이 영역에 함께 생성됩니다.

2. 힙(Heap)
⦁	 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이 곳에 생성됩니다. 즉, 인스턴스변수(instance variable)들이 생성되는 공간이다.

3. 호출스택(Call Stack 또는 Execution Stack)
⦁	호출스택은 메서드의 작업에 필요한 메모리 공간을 제공합니다.

⦁	메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용됩니다.

⦁	메서드가 작업을 마치게 되면, 할당되었던 메모리공간은 반환되어 비워집니다.

⦁	호출스택의 제일 상위에 위치하는 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 됩니다.

⦁	호출스택을 조사해 보면 메서드 간의 호출관계와 현재 수행중인 메서드가 어느 것인지 알 수 있습니다.

⦁	각 메서드를 위한 메모리상의 작업공간은 서로 구별됩니다.

⦁	첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련되고, 첫 번째 메서드 수행중에 다른 메서드를 호출하게 되면, 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련됩니다.

⦁	이 때 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드가 수행되기 시작합니다. 두 번째로 호출된 메서드가 수행을 마치게 되면, 두 번째 메서드를 위해 제공되었던 호출스택의 메모리공간이 반환되며, 첫 번째 메서드는 다시 수행을 계속하게 됩니다.

⦁	첫 번째 메서드가 수행을 마치면, 역시 제공되었던 메모리 공간이 호출스택에서 제거되며 호출스택은 완전히 비워지게 됩니다.




JVM의 메모리 관리

C언어와 C++과는 다르게, JVM의 메모리 관리는 프로그래머가 하나 하나 처리해 줄 필요 없이 자동으로 관리가 가능합니다.
메모리 관리란 기능을 크게 본다면 메모리의 생성과, 삭제로 볼 수 있는데 우리가 프로그램 내에서 변수를 선언하거나 클래스를 선언할 때  일정 부분의 메모리를 할당 받게 되는 것입니다.
메모리에서 할당이 필요해지면, JVM은 변수에 대해 실제의 내용을 포인터로써 관리를 해주게 됩니다.
JVM이 모든 객체의 레퍼런스를(참조) 카운트하고 관리하기 때문에 메모리 영역의 충돌이나 삭제 하지 않은 메모리 때문에 메모리 누수 등의 버그가 발생 할 가능성이 거의 없어 졌습니다.

JDK 1.3 이전(JIT 기반) 에서는 메모리에 대한 간접 참조 방식을 이용하였는데 간접적으로 참조하므로 실제 내용을 찾아 가기 위해서는 두번이상의 참조가 일어나게 됩니다.
따라서 프로그램의 실행 시간이 느려질 수는 있었지만, 이 경우엔 오히려 Garbage Collection시 참조만 지우면 되므로 오히려 간단했다고 볼 수 있습니다.

참고) 간접 참조란 힙에 객체의 내용이 있다면 중간에 그곳을 가리키는 메모리 영역이 있고(핸들 메모리), 스택에 있는 변수가 핸들 메모리를 참조하여 실제 힙의 주소를 얻은 후 힙의 실제 내용을 참조하게 되는 방식 입니다.
반면 직접 참조의 경우 스택에 있는 변수가 힙메모리의 실제 주소를 가지고 있어 직접 참조 하게 되는 방식 이므로,  자주 참조되는 변수나 객체가 있다면 직접 참조 방식이 더욱 뛰어난 성능을 보여주게 됩니다.

반면에 GC의 경우(메모리를 지우거나 참조값을 바꾸는 경우), 직접 참조 방식에서는 값이 없어지거나 사라져야 하는 변수에 대해 일일이 포인터를 지워줘야 합니다.
반면 간접 참조 방식의 경우 핸들 메모리만 수정을 해주면 되므로 오히려 간단해 지는 것입니다.

자바 가상 머신에서는 스택과 힙 메모리를 사용하며 스택에는 프로그램에서 사용하는 변수, 함수명등이 수행 순서에 맞게 적재 되어 있고 힙 메모리에는 실제 스택에 있는 변수나 함수의 내용이 적재 됩니다.
즉 스택에는 실제 값이 존재하는 곳의 포인터를 가지므로 크기가 크지 않으나 힙의 경우 사용량이 커지게 됩니다.

참고) 만약 힙 메모리를 다써버린다면 java.lang.OutOfMemory 오류가 발생 하게 됩니다.

이상으로 JVM의 정의와, Native 프로그램과 JVM 프로그램의 실행 구조의 차이, Just-in-time 기능과 JVM의 메모리 구조와 메모리 관리까지, 모두 살펴보았습니다.


[jekyll-docs]: http://joey914.github.io/home
[jekyll-gh]:   https://github.com/joey914/joey914
[jekyll-talk]: https://talk.joey914.com/
